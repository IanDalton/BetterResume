name: Deploy Backend (FastAPI) to VPS (Debian)

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH (Docker build & run) on Debian
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.HOMELAB_HOST }}
          username: ${{ secrets.HOMELAB_USERNAME }}
          key: ${{ secrets.HOMELAB_SSH_KEY }}
          script: |
            set -euo pipefail

            REPO_DIR="$HOME/repos/BetterResume"
            GIT_REPO="https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/IanDalton/BetterResume.git"
            APP_NAME="better-resume-backend"
            CONTAINER_NAME="better-resume"
            DATA_VOLUME="better_resume_data"
            BACKEND_DIR="$REPO_DIR/backend"
            COMMIT_SHA="${{ github.sha }}"
            IMAGE_TAG="${APP_NAME}:${COMMIT_SHA:0:12}"
            ENV_FILE="$BACKEND_DIR/.env"

            echo "== Preflight: ensure apt, curl, git =="
            if ! command -v curl >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y curl
            fi
            if ! command -v git >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y git
            fi

            echo "== Preflight: install Docker Engine if missing =="
            if ! command -v docker >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              sudo chmod a+r /etc/apt/keyrings/docker.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian trixie stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo systemctl enable --now docker
            fi

            echo "== Ensure repo present =="
            if [ ! -d "$REPO_DIR/.git" ]; then
              mkdir -p "$REPO_DIR"
              git clone "$GIT_REPO" "$REPO_DIR"
            fi
            cd "$REPO_DIR"
            git fetch origin main
            git reset --hard origin/main
            git clean -fd

            echo "== Create/refresh .env from secrets =="
            mkdir -p "$(dirname "$ENV_FILE")"
            echo "# Auto-generated by GitHub Action $(date -u)" > "$ENV_FILE"
            echo "DATA_DIR=/app/data" >> "$ENV_FILE"
            if [ -n "${{ secrets.GOOGLE_API_KEY }}" ]; then
              echo "GOOGLE_API_KEY=${{ secrets.GOOGLE_API_KEY }}" >> "$ENV_FILE"
            else
              echo "WARNING: GOOGLE_API_KEY not set; Gemini calls may fail." >&2
            fi
            # Signed download link secret (rotate per deploy)
            if command -v openssl >/dev/null 2>&1; then
              DS_SECRET=$(openssl rand -hex 32)
            else
              DS_SECRET=$(head -c 32 /dev/urandom | od -An -tx1 | tr -d ' \n')
            fi
            if [ -z "$DS_SECRET" ]; then
              # Fallback: derive from commit sha and time (less secure, but avoids empty)
              DS_SECRET="fallback-${COMMIT_SHA:0:12}-$(date +%s)"
            fi
            echo "DOWNLOAD_SIGNING_SECRET=$DS_SECRET" >> "$ENV_FILE"
            # Agregá otras variables acá si corresponde (OPENAI_API_KEY, etc)

            echo "== Build image (tagged) =="
            sudo docker build -t "$IMAGE_TAG" -t "$APP_NAME:latest" "$BACKEND_DIR"

            echo "== Create data volume if missing =="
            sudo docker volume inspect "$DATA_VOLUME" >/dev/null 2>&1 || sudo docker volume create "$DATA_VOLUME"

            echo "== Stop & remove old container (keep old image id for rollback) =="
            OLD_IMAGE_ID=""
            if sudo docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
              OLD_IMAGE_ID=$(sudo docker inspect --format='{{.Image}}' "$CONTAINER_NAME" || true)
              sudo docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
            fi

            echo "== Run new container =="
            sudo docker run -d \
              --name "$CONTAINER_NAME" \
              --restart unless-stopped \
              -p 8000:8000 \
              --env-file "$ENV_FILE" \
              -v "$DATA_VOLUME":/app/data \
              "$IMAGE_TAG"

            echo "== Health check (/health) =="
            set +e
            HEALTH_OK=0
            for i in $(seq 1 15); do
              sleep 2
              if curl -fsS http://127.0.0.1:8000/health | grep -q 'healthy'; then
                echo "Container healthy (attempt $i)."
                HEALTH_OK=1
                break
              fi
              echo "Waiting for health... ($i)"
            done
            if [ "$HEALTH_OK" -ne 1 ]; then
              echo "Health check FAILED. Showing logs:" >&2
              sudo docker logs --tail 200 "$CONTAINER_NAME" || true
              if [ -n "$OLD_IMAGE_ID" ]; then
                echo "Attempting rollback to previous image $OLD_IMAGE_ID" >&2
                sudo docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
                sudo docker run -d \
                  --name "$CONTAINER_NAME" \
                  --restart unless-stopped \
                  -p 8000:8000 \
                  --env-file "$ENV_FILE" \
                  -v "$DATA_VOLUME":/app/data \
                  "$OLD_IMAGE_ID" || true
              fi
              set -e
              exit 1
            fi
            set -e

            echo "== Prune dangling images (safe) =="
            sudo docker image prune -f >/dev/null 2>&1 || true

            echo "Deployment complete. Container status:"
            sudo docker ps --filter name="$CONTAINER_NAME"
